-- 下文对于数值类型，使用的都是小端序(相应的还有个叫大端序的东西)<br>
-- 对齐概念：数据在内存中的对齐、数据在文件中的对齐、资源文件中资源数据的对齐 <br>
-- 程序在内存中（启动，运行时）和在硬盘中（对其进行编辑，或不启动不运行时），<br>
两者的对齐规则很可能不一样，因此导致的‘地址’不一致<br>
-- 在概念时，需要把十进制的字节数换算成16进制数方便理解<br>
-- 每个段(节)都需要对齐文件粒度<br>

### DOS头
* 固定长度为64bit（字节）
* 前两位是魔数(USHORT e_magic),固定值|4D|5A|(0x5A4D)
* 后四位是文件头偏移量(LONG e_lfanew),不固定,采用小端序

### PE文件头(aka NT头)
* 前四位是PE文件头标志(DWORD Signature),固定值|50|45|00|00|(0x00004550)
* 紧接着两位(第5·6位)是运行平台(WORD Machine)，一般为|4C|01|(0x014C)
* 再后两位(第7·8位)是section个数(WORD NumberOfSections),不固定
* 再后四位(第9·10·11·12位)是时间戳(DWORD TimeDateStamp)
* 再后八位(第13·14·15·16·17·18·19·20位)是symbol相关信息,不重要
* 再后两位(第21·22位)是扩展头的大小(WORD SizeOfOptionalHeader)，32位程序是固定值|E0|00|(0x00E0)
* 再后两位(第23·24位)是文件属性(WORD Characteristics)，位运算，一般是|02|01|(0x0102)
* 接下来是扩展头
* 前两位(第1·2位)是魔数(WORD Magic)，|0B|01|(0x010B)表示32位程序,|0B|02|(0x020B)表示64位程序
* 接下来14位不重要(第3到16位）
* 接下来四位(第17·18·19·20位)是入口点(AddressOfEntryPoint),RVA,|00|10|00|00|(0x00001000)
* 接下来八位不重要(第21到28位）
* 接下来四位(第29·30·31·32位)是imagebase(DWORD ImageBase),|00|00|40|00|(0x00400000)
* 接下来四位(第33·34·35·36位)是段对齐粒度(DWORD SectionAlignment),|00|10|00|00|(0x00001000)
* 接下来四位(第37·38·39·40位)是文件对齐粒度(DWORD FileAlignment),|00|02|00|00|(0x00000200)
* 接下来八位不重要(第41到48位）
* 接下来两位(第49·50位)是系统最小版本要求(WORD MajorSubsystemVersion),|04|00|(0x0004),6表示win7以上，4可以使用xp
* 接下来六位不重要(第41到56位）
* 接下来四位(第57·58·59·60位)是占用内存大小(DWORD SizeOfImage),|00|30|00|00|(0x00003000)，对齐之前的段对齐粒度
* 接下来四位(第61·62·63·64位)是头大小(DWORD SizeOfHeaders),|00|02|00|00|(0x00000200)
* 接下来四位不重要(第64到68位）
* 接下来两位(第69·70位)是程序类型(WORD Subsystem)，|02|00|(0x0002)，2为窗口程序，没有控制台
* 接下来两位(第71·72位)是属性(WORD DllCharacteristics)，|00|81|(0x8100)
* 接下来二十位不重要(第73到92位）
* 接下来四位(第93·94·95·96位)是数据目录表个数(DWORD NumberOfRvaAndSizes),|10|00|00|00|(0x00000010)
* 接下来是扩数据目录表数组128个字节(80h)
* 一共均分成16份，每份占8H
* 8H中前4H是这个部分在文件中的RVA，后4H是这个部分占的大小

## 一些数值的计算
* imageBase --- 当被以进程方式加载到内存时的期望基址
* offset  --- 在以文件形式被读取时，
* raw  --- 当以文件形式被读取时，(xxx在十六进制文件中的)实际地址
* va   --- 当以进程方式加载到内存时，(xxx在内存中的)实际地址
* RVA  --- 当以进程方式加载到内存时,(xxx在内存中相对于基址的)地址，是个相对的概念，一定要有个参照物
* AddressOfNewExeHeader --- 记录PE部分的起始位置
* NumberOfSections --- 段(section)的数量
* SizeOfOptionalHeader --- 扩展头大小，32位是|E0|00|,64位是|F0|00|
* OPTIONAL_MAGIC --- 魔数，32位系统是|0B|01|,64位系统是|0B|02|
* SizeOfCode --- code段的大小，这个段必须存在
* SizeOfInitializedData --- data段的大小，这个段必须存在
* AddressOfEntryPoint --- 程序入口地址RVA
* BaseOfCode --- code段的起始地址RVA，必须是SectionAlignment的整数倍
* BaseOfData --- data段的起始地址RVA，必须是FileAlignment的整数倍
* SectionAlignment --- 在读取到内存时，每个段需要对齐的字节,1000h(4K对齐)
* FileAlignment --- 在文件中，每个段需要对齐的字节，200h
* MajorOperatingSystemVersion --- 操作系统版本要求
* MajorSubsystemVersion --- 子系统版本要求
* SizeOfImage --- 所有的段的大小加起来(是内存中的值，而且需要对齐)，所以这个值一定是SectionAlignment的整数倍
* SizeOfHeaders --- dos头(包括)到区段表(包括)，也就是除了段之外的其他内容的大小，对齐标准是文件中的概念，所以是FileAlignment的整数倍

```
当文件未被加载到内存时:
文件的基址为0

当文件被加载到内存时:
文件的基址是在PE头(NT头)中，
具体是(IMAGE_NT_HEADERS)-->>(IMAGE_OPTIONAL_HEADER32)-->>(ImageBase)

对齐：
在文件中的对齐方式和在内存中的对齐一般来说是不一样的，其值由PE头(NT头)中的某项决定，
具体是(IMAGE_NT_HEADERS)-->>(IMAGE_OPTIONAL_HEADER32)-->>(SectionAlignment)/(FileAlignment)
其中，对齐规则是，整个信息头(DOS头，DOS存根，NT头)占据的空间需要对齐，每个段(.text, .rdata, .data, etc)都分别需要对齐，
就是因为在不同的情况下对齐标准不一样，所以才产生了地址的转换！！！
转换的核心原理就是，对齐只是移动了段头的地址，那些紧跟着段头的数据，某种意义上来说其地址并没有变化，这些数据相对于段头的距离并没有变化

举个例子:
1. HI00SAY0FAR0 -- 没有被读取到内存时，在文件中的对齐方式是4个字节,每个词占4字节，不足则补零
2. ?HI000000SAY00000FAR00000 --读取到内存时， 在内存中对齐方式是8字节，每个词占8字节，不足则补零

在情形1中，H=1, I=2, S=5, Y=7, F=9, R=11
在情形2中，H=?+1, I=?+2, S=?+9, Y=?+11, F=?+17, R=?+19
?代表的是被读取到内存时的基址
用相对关系来表示就是：
在情形1中，H=1, I=H+1, S=5, Y=S+2, F=9, R=F+2
在情形2中，H=?+1, I=H+1, S=?+9, Y=S+2, F=?+17, R=F+2

在实际情景中，像H,S,F这样的起始段，他们的坐标都是可以直接找到的。然后像I,Y,R这样的，就需要间接求出来,
一般发生在反汇编调试的时候，在调试的时候用工具看到的地址都是情景2那样的，如果要修改文件里的数据，就要把地址变成情景1那样的
```




